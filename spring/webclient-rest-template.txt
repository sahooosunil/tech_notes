### **WebClient vs RestTemplate in Spring Boot**  

Spring provides **RestTemplate** (synchronous) and **WebClient** (reactive) for making HTTP calls. Below is a comparison to help you decide when to use which.

---

## **1ï¸âƒ£ RestTemplate (Synchronous)**
**âœ… When to Use:**  
- Simple and traditional **blocking** HTTP calls.  
- If the application is not reactive and does not need non-blocking execution.  
- When working in a monolithic architecture or synchronous microservices.  

### **ğŸ”¹ Example Usage**
```java
RestTemplate restTemplate = new RestTemplate();
String response = restTemplate.getForObject("https://api.example.com/data", String.class);
System.out.println(response);
```

### **ğŸ”¹ Advantages**
âœ… Simple and easy to use.  
âœ… Works well for traditional Spring MVC applications.  
âœ… Well-documented and widely adopted.

### **ğŸ”¹ Disadvantages**
âŒ **Blocking (Synchronous):** A thread is blocked until the response is received.  
âŒ **Deprecated:** Spring recommends **WebClient** instead.  
âŒ **Not efficient for high-throughput applications.**  

---

## **2ï¸âƒ£ WebClient (Asynchronous & Reactive)**
**âœ… When to Use:**  
- Non-blocking, **asynchronous** HTTP calls.  
- Microservices architecture where performance and scalability matter.  
- Working with **Spring WebFlux** or reactive programming.  
- Streaming large amounts of data (e.g., Server-Sent Events).  

### **ğŸ”¹ Example Usage**
```java
WebClient webClient = WebClient.create("https://api.example.com");
String response = webClient.get()
        .retrieve()
        .bodyToMono(String.class)
        .block(); // Blocks only if needed
System.out.println(response);
```

### **ğŸ”¹ Advantages**
âœ… **Non-blocking & Asynchronous** â†’ Uses fewer resources for high-load systems.  
âœ… **Better performance** in a reactive environment.  
âœ… **Supports streaming** for large data.  
âœ… **More flexible** than RestTemplate.  

### **ğŸ”¹ Disadvantages**
âŒ **More complex than RestTemplate.**  
âŒ **Needs additional setup for synchronous calls** (`.block()`).  
âŒ **Steeper learning curve** if you're not familiar with reactive programming.  

---

## **3ï¸âƒ£ When to Choose What?**
| Scenario | Use **RestTemplate** | Use **WebClient** |
|----------|----------------|----------------|
| Simple synchronous calls | âœ… Yes | âŒ No |
| High-performance & scalability | âŒ No | âœ… Yes |
| Spring MVC (Blocking) | âœ… Yes | âŒ No |
| Spring WebFlux (Reactive) | âŒ No | âœ… Yes |
| Streaming large data (SSE) | âŒ No | âœ… Yes |
| Making multiple concurrent calls | âŒ No | âœ… Yes |

---

### **ğŸš€ Final Recommendation**
- If working with **Spring WebFlux** â†’ **Use WebClient** (fully non-blocking).  
- If in a **Spring MVC (Blocking) project**, and performance is **not a concern**, RestTemplate is fine.  
- If making **high-volume API calls**, prefer WebClient.  
- **Spring recommends WebClient over RestTemplate**, as RestTemplate is being phased out.

----------------------------------------
## **Spring WebClient Examples: GET, POST, PUT, DELETE (Mono & Flux)**  

`WebClient` is a **non-blocking, reactive HTTP client** in Spring WebFlux. Below are examples of how to use it for different HTTP methods with **Mono** (single result) and **Flux** (multiple results).  

---

## **1ï¸âƒ£ Setting Up WebClient**
```java
import org.springframework.web.reactive.function.client.WebClient;

WebClient webClient = WebClient.create("https://api.example.com");
```

---

## **2ï¸âƒ£ GET Request (Mono & Flux)**
### **ğŸŸ¢ GET (Fetching a Single Object) - Mono**
```java
Mono<String> responseMono = webClient.get()
        .uri("/user/{id}", 1)
        .retrieve()
        .bodyToMono(String.class);

responseMono.subscribe(System.out::println); // Non-blocking: prints response when available
```
ğŸ”¹ **`bodyToMono(String.class)`** â†’ Converts response into a single object (`Mono`).  

---

### **ğŸŸ¢ GET (Fetching a List of Objects) - Flux**
```java
Flux<String> responseFlux = webClient.get()
        .uri("/users")
        .retrieve()
        .bodyToFlux(String.class);

responseFlux.subscribe(System.out::println); // Prints each user one by one
```
ğŸ”¹ **`bodyToFlux(String.class)`** â†’ Converts response into a stream of multiple objects (`Flux`).  

---

## **3ï¸âƒ£ POST Request (Creating a Resource)**
```java
Mono<String> postResponse = webClient.post()
        .uri("/users")
        .bodyValue(new User("John", "Doe"))  // Sending request body
        .retrieve()
        .bodyToMono(String.class);

postResponse.subscribe(System.out::println); // Prints response (e.g., created user ID)
```
ğŸ”¹ **`bodyValue(object)`** â†’ Sends the request body in JSON format.  
ğŸ”¹ **`retrieve().bodyToMono(String.class)`** â†’ Retrieves the response as a `Mono`.  

---

## **4ï¸âƒ£ PUT Request (Updating a Resource)**
```java
Mono<String> putResponse = webClient.put()
        .uri("/users/{id}", 1)
        .bodyValue(new User("UpdatedName", "UpdatedLastName"))
        .retrieve()
        .bodyToMono(String.class);

putResponse.subscribe(System.out::println);
```
ğŸ”¹ **Updates an existing user with `id=1`**.  
ğŸ”¹ The response could be a success message or updated user details.  

---

## **5ï¸âƒ£ DELETE Request (Deleting a Resource)**
```java
Mono<Void> deleteResponse = webClient.delete()
        .uri("/users/{id}", 1)
        .retrieve()
        .bodyToMono(Void.class);

deleteResponse.subscribe(unused -> System.out.println("User deleted"));
```
ğŸ”¹ **`Void.class`** â†’ No response body is expected.  
ğŸ”¹ **`subscribe()`** executes the request asynchronously.  

---

## **6ï¸âƒ£ Handling Errors (onStatus)**
```java
Mono<String> response = webClient.get()
        .uri("/users/{id}", 999) // Non-existing user
        .retrieve()
        .onStatus(status -> status.value() == 404, 
                  clientResponse -> Mono.error(new RuntimeException("User Not Found")))
        .bodyToMono(String.class)
        .doOnError(error -> System.out.println("Error: " + error.getMessage()));

response.subscribe(System.out::println);
```
ğŸ”¹ **`onStatus()`** â†’ Custom error handling for HTTP status codes.  
ğŸ”¹ **`doOnError()`** â†’ Handles errors without breaking the flow.  

---

## **7ï¸âƒ£ WebClient Exchange (More Control Over Response)**
```java
Mono<ClientResponse> clientResponseMono = webClient.get()
        .uri("/users/{id}", 1)
        .exchangeToMono(response -> {
            if (response.statusCode().is2xxSuccessful()) {
                return response.bodyToMono(String.class);
            } else {
                return Mono.error(new RuntimeException("Request failed"));
            }
        });

clientResponseMono.subscribe(System.out::println);
```
ğŸ”¹ **`exchangeToMono()`** â†’ Gives full control over the response.  

---

## **ğŸ¯ When to Use Mono vs Flux?**
| **Scenario** | **Use** |
|-------------|---------|
| Fetching a **single object** (GET by ID) | `Mono<T>` |
| Fetching **multiple objects** (GET all) | `Flux<T>` |
| Creating, updating, deleting | `Mono<T>` |
| Handling API errors | `Mono<T>` |

---

### **ğŸš€ Key Takeaways**
âœ… `WebClient` is **non-blocking** and efficient.  
âœ… `Mono` â†’ **For single objects** (One response).  
âœ… `Flux` â†’ **For multiple objects** (Streaming).  
âœ… `onStatus()` for handling HTTP errors.  
âœ… `exchangeToMono()` for **full response control**.  

Would you like a **Spring Boot example** with a real API? ğŸš€
-----------------------------------------
## **Spring Cloud OpenFeign Example**  

**Feign Client** is a declarative REST client in Spring Cloud that simplifies calling external APIs.

---

### **1ï¸âƒ£ Add Dependencies**
Add the required dependencies in `pom.xml`:
```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```
Make sure to include **Spring Cloud BOM**:
```xml
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>${spring-cloud.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

---

### **2ï¸âƒ£ Enable Feign in Spring Boot**
In your main Spring Boot class, enable Feign clients:
```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableFeignClients  // Enables Feign Clients
public class FeignClientApplication {
    public static void main(String[] args) {
        SpringApplication.run(FeignClientApplication.class, args);
    }
}
```

---

### **3ï¸âƒ£ Define a Feign Client**
Create an interface for calling an external API:
```java
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

// Define a Feign client with a base URL
@FeignClient(name = "userClient", url = "https://jsonplaceholder.typicode.com")
public interface UserClient {

    @GetMapping("/users/{id}")
    User getUserById(@PathVariable("id") Long id);
}
```
âœ… **`@FeignClient(name = "userClient", url = "...")`** â†’ Defines the external API.  
âœ… **`@GetMapping("/users/{id}")`** â†’ Maps to the actual API endpoint.  
âœ… **`User getUserById(Long id)`** â†’ Calls the API and returns a `User` object.  

---

### **4ï¸âƒ£ Create a Model Class**
```java
public class User {
    private Long id;
    private String name;
    private String email;

    // Getters and Setters
}
```

---

### **5ï¸âƒ£ Inject Feign Client in a Service**
```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    @Autowired
    private UserClient userClient;

    public User getUser(Long id) {
        return userClient.getUserById(id);
    }
}
```

---

### **6ï¸âƒ£ Expose a REST API to Test Feign**
```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping("/fetch-user/{id}")
    public User fetchUser(@PathVariable Long id) {
        return userService.getUser(id);
    }
}
```
âœ… **Feign will automatically call `https://jsonplaceholder.typicode.com/users/{id}`**  

---

### **7ï¸âƒ£ Run & Test**
Start the Spring Boot application and test using:
```
GET http://localhost:8080/fetch-user/1
```
ğŸ¯ **Feign will make an HTTP request to `https://jsonplaceholder.typicode.com/users/1` and return the response.**  

---

### **âœ¨ Advantages of Feign**
âœ”ï¸ **Declarative API calls (No `RestTemplate`)**  
âœ”ï¸ **Built-in integration with Spring Cloud**  
âœ”ï¸ **Automatic serialization/deserialization**  
âœ”ï¸ **Load balancing (with Ribbon or Spring Cloud LoadBalancer)**  

Would you like to see **a Feign client with authentication**? ğŸš€